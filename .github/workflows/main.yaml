name: workflow

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'README.md'

permissions:
  id-token: write
  contents: read

jobs:
  integration:
    name: Continuous Integration
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Lint code
        run: echo "Linting repository"

      - name: Run unit tests
        run: echo "Running unit tests"

  build-and-push-ecr-image:
    name: Continuous Delivery
    needs: integration
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Install Utilities
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME }}
          IMAGE_TAG: latest
        run: |
          # Build a docker container and
          # push it to ECR so that it can
          # be deployed to ECS.
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "::set-output name=image::$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          
  Continuous-Deployment:
    needs: build-and-push-ecr-image
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Free up disk space immediately
        run: |
          echo "=== EMERGENCY DISK CLEANUP ==="
          # Check current space
          AVAILABLE_KB=$(df / | awk 'NR==2 {print $4}')
          AVAILABLE_GB=$((AVAILABLE_KB / 1024 / 1024))
          echo "Current available space: ${AVAILABLE_GB}GB"
          
          # Stop Docker daemon first for complete cleanup
          echo "Stopping Docker daemon..."
          sudo systemctl stop docker || true
          
          # Remove all Docker data completely
          echo "Removing all Docker data..."
          sudo rm -rf /var/lib/docker/* 2>/dev/null || true
          
          # Clean system directories aggressively
          echo "Cleaning system directories..."
          sudo rm -rf /opt/hostedtoolcache/* 2>/dev/null || true
          sudo rm -rf /usr/share/dotnet 2>/dev/null || true
          sudo rm -rf /usr/local/lib/android 2>/dev/null || true
          sudo rm -rf /usr/local/share/boost 2>/dev/null || true
          sudo rm -rf /usr/local/lib/node_modules 2>/dev/null || true
          sudo rm -rf /home/runner/.cache/* 2>/dev/null || true
          sudo rm -rf /root/.cache/* 2>/dev/null || true
          sudo rm -rf /tmp/* 2>/dev/null || true
          sudo rm -rf /var/tmp/* 2>/dev/null || true
          sudo rm -rf ~/.cache/* 2>/dev/null || true
          
          # Clean package manager caches
          echo "Cleaning package caches..."
          sudo apt-get clean 2>/dev/null || true
          sudo apt-get autoremove -y 2>/dev/null || true
          sudo apt-get autoclean -y 2>/dev/null || true
          
          # Clean logs
          sudo journalctl --vacuum-time=1d 2>/dev/null || true
          sudo rm -rf /var/log/*.log 2>/dev/null || true
          
          # Restart Docker
          echo "Restarting Docker daemon..."
          sudo systemctl start docker
          sleep 15
          
          # Show final space
          echo "=== SPACE AFTER CLEANUP ==="
          df -h /
          
          # Verify we have enough space
          FINAL_KB=$(df / | awk 'NR==2 {print $4}')
          FINAL_GB=$((FINAL_KB / 1024 / 1024))
          echo "Final available space: ${FINAL_GB}GB"
          
          if [ $FINAL_GB -lt 4 ]; then
            echo "❌ ERROR: Still only ${FINAL_GB}GB available after cleanup."
            echo "Your runner needs more disk space. Consider:"
            echo "1. Expanding the disk size"
            echo "2. Using a larger instance"
            echo "3. Setting up regular cleanup scripts"
            exit 1
          fi

      - name: Check disk space before cleanup
        run: |
          echo "=== Disk usage before cleanup ==="
          df -h
          echo "=== Docker disk usage ==="
          docker system df
          echo "=== Docker images ==="
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

      - name: Emergency disk space check
        run: |
          # Check if we have less than 2GB free space
          AVAILABLE_KB=$(df / | awk 'NR==2 {print $4}')
          AVAILABLE_GB=$((AVAILABLE_KB / 1024 / 1024))
          echo "Available space: ${AVAILABLE_GB}GB"
          
          if [ $AVAILABLE_GB -lt 2 ]; then
            echo "⚠️  WARNING: Less than 2GB available, performing emergency cleanup..."
            # Stop all containers immediately
            docker stop $(docker ps -aq) 2>/dev/null || true
            docker rm $(docker ps -aq) 2>/dev/null || true
            # Remove ALL images except the one we're about to pull
            docker rmi $(docker images -q) 2>/dev/null || true
            # Clean everything
            docker system prune -af --volumes
          fi

      - name: Comprehensive Docker cleanup
        run: |
          echo "=== Stopping and removing containers ==="
          # Stop and remove all containers
          docker stop $(docker ps -aq) 2>/dev/null || true
          docker rm $(docker ps -aq) 2>/dev/null || true
          
          echo "=== Removing unused images and networks ==="
          # Remove all unused images, networks, and build cache
          docker system prune -af --volumes
          
          echo "=== Removing dangling and unused images ==="
          # Remove dangling images
          docker image prune -af
          
          # Remove old images (keep only latest few)
          docker images --format "{{.Repository}}:{{.Tag}} {{.ID}}" | grep -v "latest" | head -n -3 | awk '{print $2}' | xargs -r docker rmi 2>/dev/null || true
          
          echo "=== System cleanup ==="
          # Clean system caches
          rm -rf ~/.cache/pip/* 2>/dev/null || true
          sudo apt-get clean 2>/dev/null || true
          sudo rm -rf /tmp/* 2>/dev/null || true
          sudo rm -rf /var/tmp/* 2>/dev/null || true
          
          # Clean Docker logs
          sudo truncate -s 0 /var/lib/docker/containers/*/*-json.log 2>/dev/null || true

      - name: Check disk space after cleanup
        run: |
          echo "Disk usage after cleanup:"
          df -h
          echo "Available space in root:"
          df -h / | awk 'NR==2{printf "Available: %s (Used: %s)\n", $4, $5}'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      
      - name: Stop and remove existing mltest container
        run: |
          if docker ps -q --filter "name=mltest" | grep -q .; then
            echo "Stopping existing mltest container..."
            docker stop mltest
            docker rm -f mltest
          else
            echo "No existing mltest container found"
          fi
      
      - name: Pre-pull disk space check
        run: |
          echo "=== Checking available space before pulling image ==="
          AVAILABLE_KB=$(df / | awk 'NR==2 {print $4}')
          AVAILABLE_GB=$((AVAILABLE_KB / 1024 / 1024))
          echo "Available space: ${AVAILABLE_GB}GB"
          
          if [ $AVAILABLE_GB -lt 5 ]; then
            echo "⚠️  WARNING: Less than 5GB available for image pull!"
            echo "Performing additional aggressive cleanup..."
            
            # Stop Docker daemon temporarily and clean everything
            sudo systemctl stop docker
            
            # Clean Docker root directory more aggressively
            sudo rm -rf /var/lib/docker/tmp/* 2>/dev/null || true
            sudo rm -rf /var/lib/docker/overlay2/* 2>/dev/null || true
            sudo rm -rf /var/lib/docker/image/* 2>/dev/null || true
            sudo rm -rf /var/lib/docker/containers/* 2>/dev/null || true
            
            # Clean more system directories
            sudo rm -rf /opt/hostedtoolcache/* 2>/dev/null || true
            sudo rm -rf /usr/share/dotnet 2>/dev/null || true
            sudo rm -rf /usr/local/lib/android 2>/dev/null || true
            sudo rm -rf /usr/local/share/boost 2>/dev/null || true
            sudo rm -rf /usr/local/lib/node_modules 2>/dev/null || true
            sudo rm -rf /home/runner/.cache/* 2>/dev/null || true
            sudo rm -rf /root/.cache/* 2>/dev/null || true
            
            # Clean package manager caches
            sudo apt-get autoremove -y 2>/dev/null || true
            sudo apt-get autoclean -y 2>/dev/null || true
            sudo journalctl --vacuum-time=1d 2>/dev/null || true
            
            # Restart Docker
            sudo systemctl start docker
            sleep 10
            
            echo "=== Space after aggressive cleanup ==="
            df -h /
          fi
      
      - name: Pull latest images with chunked strategy
        run: |
          echo "=== Final pre-pull space check ==="
          df -h /
          
          # Check if we have enough space (at least 4GB)
          AVAILABLE_KB=$(df / | awk 'NR==2 {print $4}')
          AVAILABLE_GB=$((AVAILABLE_KB / 1024 / 1024))
          
          if [ $AVAILABLE_GB -lt 4 ]; then
            echo "❌ ERROR: Only ${AVAILABLE_GB}GB available. Need at least 4GB for safe image pull."
            echo "Please increase disk space on your self-hosted runner."
            exit 1
          fi
          
          echo "✅ Sufficient space available: ${AVAILABLE_GB}GB"
          echo "Pulling latest image..."
          
          # Pull with retry mechanism and better error handling
          IMAGE_URI="${{secrets.AWS_ECR_LOGIN_URI}}/${{ secrets.ECR_REPOSITORY_NAME }}:latest"
          
          for i in {1..3}; do
            echo "Pull attempt $i/3..."
            if docker pull --quiet "$IMAGE_URI"; then
              echo "✅ Image pulled successfully"
              break
            else
              echo "❌ Pull attempt $i failed"
              if [ $i -eq 3 ]; then
                echo "All pull attempts failed. Checking space..."
                df -h /
                exit 1
              fi
              
              echo "Cleaning up before retry..."
              docker system prune -af
              sleep 5
            fi
          done
          
          echo "=== Post-pull space check ==="
          df -h /
         
      - name: Clean up old images after pull
        run: |
          echo "Removing old versions of the same image..."
          # Keep only the latest tag and remove other versions
          IMAGE_REPO="${{secrets.AWS_ECR_LOGIN_URI}}/${{ secrets.ECR_REPOSITORY_NAME }}"
          docker images --format "{{.Repository}}:{{.Tag}} {{.ID}}" | grep "$IMAGE_REPO" | grep -v ":latest" | awk '{print $2}' | xargs -r docker rmi 2>/dev/null || true
         
      - name: Run Docker Image to serve users
        run: |
          echo "Starting new mltest container..."
          docker run -d -p 8080:8080 --ipc="host" --name=mltest \
            -e 'AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}' \
            -e 'AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
            -e 'AWS_REGION=${{ secrets.AWS_REGION }}' \
            ${{secrets.AWS_ECR_LOGIN_URI}}/${{ secrets.ECR_REPOSITORY_NAME }}:latest

      - name: Verify container is running
        run: |
          echo "Checking container status..."
          docker ps --filter "name=mltest"
          
      - name: Final cleanup of unused resources
        run: |
          echo "Final cleanup of unused images and containers..."
          docker system prune -f
